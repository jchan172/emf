import os
import numpy as np

from ..emf_funks import (_path_manage, _check_extension, _is_number,
                        _check_intable, _flatten, _sig_figs)

from subcalc_class import Model, Footprint

def load_model(*args):
    """Read a .REF output file and load the data into a Model object
    args:
        REF_path - string, path to the output .REF file of field results
        footprint_path - string, path to the csv file of footprints
    returns
        mod - Model object containing results"""

    #load field results into a model
    data, grid_info = read_REF(args[0])
    mod = Model(data, grid_info)

    if(len(args) > 1):
        #load footprints into the model
        mod.load_footprints(args[1])

    return(mod)

def read_REF(file_path):
    """Reads a .REF output file generated by the SUBCALC program and pulls
    out information about the reference grid of the model with the Res and
    Max magnetic fields.
    args:
        file_path - string, path to saved .REF output file
    returns:
        data - dict, keys are 'x', 'y', 'Bmax', 'Bres', 'Bx', and 'By'
        grid - dict, reference grid information"""

    #check the extension
    file_path = _check_extension(file_path, 'REF', """
        SubCalc results are saved to text files with .REF extensions.
        The input path:
            "%s"
        does not have the correct extension.""" % file_path)

    #allocate dictionaries
    grid_info = {} #dictionary storing reference grid information
    keys = ['X Coord', 'Y Coord', 'X Mag', 'Y Mag', 'Max', 'Res']
    return_keys = ['x', 'y', 'Bx', 'By', 'Bmax', 'Bres']
    data = dict(zip(keys, [[] for i in range(len(keys))]))

    #pull data out
    with open(file_path, 'r') as ifile:
        #read through unwanted lines
        for i in range(9):
            ifile.readline()
        #store information about the grid
        for i in range(13):
            line = ifile.readline().strip()
            if(line):
                line = line.split(':')
                if(_is_number(line[1])):
                    grid_info[line[0]] = float(line[1])
                else:
                    grid_info[line[0]] = line[1].strip()
        #read through the rest of the data
        for line in ifile:
            for k in keys:
                if(k == line[:len(k)]):
                    L = line[line.index(':') + 1:]
                    data[k].append([float(i) for i in L.split()[2:]])

    #flatten the lists in data
    for k in data:
        data[k] = np.array(_flatten(data[k]))

    #switch the keys
    data = dict(zip(return_keys, [data[k] for k in keys]))

    return(data, grid_info)

def _bilinear_interp(mod, x, y):
    """Use Model results to interpolate linearly in two dimensions for an
    estimate of any x,y coordinate inside the grid.
    args:
        mod - Model object
        x - float, x coordinate to interpolate at
        y - float, y coordinate to interpolate at
    returns:
        B_interp - float, interpolated field value"""
    #first find the 4 point grid cell containing x,y
    #   (the point is assumed to lie inside the grid)
    xidx = np.arange(len(mod.x))[(mod.x - x) > 0.][:2] - 1
    yidx = np.arange(len(mod.y))[(mod.y - y) < 0.][:2] - 1
    #get coordinates and values
    x1, x2 = mod.x[xidx]
    y1, y2 = mod.y[yidx]
    B11 = mod.B[yidx[0], xidx[0]]
    B12 = mod.B[yidx[0], xidx[1]]
    B21 = mod.B[yidx[1], xidx[0]]
    B22 = mod.B[yidx[1], xidx[1]]
    #interpolate
    B_interp = (1.0/((x2 - x1)*(y2 - y1)))*(
        B11*(x2 - x)*(y2 - y) + B21*(x - x1)*(y2 - y)
        + B12*(x2 - x)*(y - y1) + B22*(x - x1)*(y - y1))

    return(B_interp)

def _2Dmax(G):
    """Find the indices of the maximum value in an 2 dimensional array
    args:
        G - 2D numpy array
    returns:
        m - the maximum value
        i - index of max along 0th axis
        j - index of max along 1st axis"""
    imax, jmax = 0, 0
    m = np.min(G)
    for i in range(G.shape[0]):
        for j in range(G.shape[1]):
            if(G[i,j] > m):
                m = G[i,j]
                imax = i
                jmax = j
    return(m, imax, jmax)

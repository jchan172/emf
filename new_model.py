import numpy as np
import matplotlib.pyplot as plt

class FLDError(Exception):
    def __init__(self, message):
        self.message = message
    def __str__(self):
        return(self.message)
        
def forward_substitution(A,b):
    """forward substitution to solve a lower triangular matrix equation"""
    n = len(b)
    x = np.empty((n,))
    for i in range(n):
        x[i] = (b[i] - sum([A[i,j]*x[j] for j in range(i)]))/float(A[i,i])
    return(x)

def Crout_backward_substitution(A,b):
    """back substitution assuming all diagonal elements of A matrix equal 1"""
    n = len(b)
    x = np.empty((n,))
    for i in range(n-1,-1,-1):
        x[i] = b[i] - sum([A[i,j]*x[j] for j in range(i+1,n)])
    return(x)

def Crout_factorization(A):
    """Crout LU matrix decomposition, returning a single matrix storing
    L and U where the diagonal of U are omitted because they are all 1."""
    #copy input matrix and make declarations
    M = A[:,:]
    n = A.shape[0]
    LU = np.empty((n,n))
    #factorize
    for i in range(n):
        #fill in a column of L
        for j in range(i,n):
            LU[j,i] = M[j,i] - sum([LU[j,k]*LU[k,i] for k in range(j)])
        #fill in a row of U
        for j in range(i+1,n):
            LU[i,j] = (M[i,j] - sum([LU[i,k]*LU[k,j] for k in range(i)]))/LU[i,i]
    return(LU)

def E_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y):
    """Calculate the approximate electric field generated by a group of
    conductors. Each of the variables labeled '_cond' should be an numpy
    array of parameters, where each index in those arrays describes a
    unique conductor, i.e. the 0th value in each variable is attributed to
    one power line."""

    #check lengths of x and y
    if(len(x) != len(y)):
        raise(FLDError('Inputs x and y must have the same lenghts, forming x-y pairs.'))

    #Define a time interval with the maximum amount of time required to
    #complete one cycle (the period).
    if(any(np.diff(f_cond))):
        raise(FLDError('At least one input frequency is different than the others. Calculations assume they are uniform.'))
    T = 1./f_cond[0]
    t = np.linspace(0, T, 1001)

    #convenient variables/constants
    epsilon = 8.854e-12
    C = 1./(2.*np.pi*epsilon)
    L = len(t)          #number of time steps
    N = len(f_cond)     #number of conductors
    Z = len(x)          #number of sample points or x,y pairs

    #calculate the effective conductor diameters
    d_cond  = d_bund*((subconds*d_cond/d_bund)**(1./subconds))

    #conversions
    w_cond = 2*np.pi*f_cond         #convert to radians
    x_cond = x_cond*0.3048          #convert to meters
    y_cond = y_cond*0.3048          #convert to meters
    d_cond = d_cond*0.0254          #convert to meters
    V_cond = V_cond/np.sqrt(3)      #convert to ground reference from line-line
                                    #reference
                                    #leave in kV
    p_cond = p_cond*2*np.pi/360.    #convert to radians
    x      = x*0.3048               #convert to meters
    y      = y*0.3048               #convert to meters

    #compute the potential coefficient matrix
    P = np.empty((N,N))
    #diagonals
    for i in range(N):
        P[i,i] = C*np.log(4*y_cond[i]/d_cond[i])
    #other elements
    for i in range(N):
        for j in range(N):
            if(i != j):
                n = (x_cond[i] - x_cond[j])**2 + (y_cond[i] + y_cond[j])**2
                d = (x_cond[i] - x_cond[j])**2 + (y_cond[i] - y_cond[j])**2
                P[i,j] = C*np.sqrt(np.log(n/d))

    #Crout LU decomposition of the P matrix to avoid repeated inversion
    P_LU = Crout_factorization(P)

    #Compute time dependent voltage signals. Each column represents the signal
    #for a conductor, with rows representative of the different times.
    V = np.empty((L,N))
    for i in range(N):
        V[:,i] = V_cond[i]*np.cos(w_cond[i]*t + p_cond[i])

    #Compute the charge, same format as the 'V' with each conductor in a column.
    #Each time represents a different voltage configuration of all the
    #conductors. Solve the matrix equation [P][Q] = [V] for each time step.
    Q = np.empty((L,N))
    for i in range(L):
        M = forward_substitution(P_LU, V[i,:])
        Q[i,:] = Crout_backward_substitution(P_LU, M)

    #Compute the x and y components of the electric field. The columns (1st
    #dimension) of the arrays represent x,y pairs and the rows represent
    #times or charge configurations
    E_x = np.zeros((L,Z))
    E_y = np.zeros((L,Z))
    for i in range(Z): #x,y pairs
        for j in range(L): #time steps
            for k in range(N): #conductors
                #x component
                nx = C*Q[j,k]*(x[i] - x_cond[k])
                d1 = (x_cond[k] - x[i])**2 + (y_cond[k] - y[i])**2
                d2 = (x_cond[k] - x[i])**2 + (y_cond[k] + y[i])**2
                E_x[j,i] += nx/d1 - nx/d2

                #y component
                ny1 = C*Q[j,k]*(y[i] - y_cond[k])
                ny2 = C*Q[j,k]*(y[i] + y_cond[k])
                E_y[j,i] += ny1/d1 - ny2/d2

    #compute resultant field magnitude
    #E = np.sqrt(E_x**2 + E_y**2)
    return(E_x, E_y)
    
def B_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y):
    """Calculate the approximate magnetic field generated by a group of
    conductors. Each of the variables labeled '_cond' should be an numpy
    array of parameters, where each index in those arrays describes a
    unique conductor, i.e. the 0th value in each variable is attributed to
    one power line."""
    
    #Define a time interval with the maximum amount of time required to
    #complete one cycle (the period).
    if(any(np.diff(f_cond))):
        raise(FLDError('At least one input frequency is different than the others. Calculations assume they are uniform.'))
    T = 1./f_cond[0]
    t = np.linspace(0, T, 1001)

    #convenient variables/constants
    mu = 4*np.pi*1e-7
    C = 1./(2*np.pi)
    L = len(t)          #number of time steps
    N = len(f_cond)     #number of conductors
    Z = len(x)          #number of sample points or x,y pairs

    #conversions
    w_cond = 2*np.pi*f_cond         #convert to radians
    x_cond = x_cond*0.3048          #convert to meters
    y_cond = y_cond*0.3048          #convert to meters
    p_cond = p_cond*2*np.pi/360.    #convert to radians
    x      = x*0.3048               #convert to meters
    y      = y*0.3048               #convert to meters
    
    #generate time varying current signals for each conductor, with each
    #conductor in a column and each row representative of a time step
    I = np.empty((L,N))
    for i in range(N):
        I[:,i] = I_cond[i]*np.cos(w_cond[i]*t + p_cond[i])
    
    #Compute x and y components of the B field at each point. The columns
    #of B_x and B_y represent x,y pairs and the rows represent time steps 
    #or current snapshots
    B_x = np.zeros((L,Z))
    B_y = np.zeros((L,Z))
    for i in range(Z): #x,y pairs
        for j in range(L): #time steps
            for k in range(N): #conductors
                dx = x[i] - x_cond[k]
                dy = y[i] - y_cond[k]
                d = np.sqrt(dx**2 + dy**2)
                B = C*I[j,k]/d
                theta = np.arctan(np.abs(dy/dx))
                B_x[j,i] += -np.sign(dy)*np.cos(theta)*B
                B_y[j,i] += np.sign(dx)*np.sin(theta)*B
    
    #compute resultant field magnitude
    #B = np.sqrt(B_x**2 + B_y**2)
    return(B_x, B_y)
            
#sample locations
x = np.arange(-25, 26)
y = 3*np.ones((len(x),))

#conductor properties
f_cond = np.array([60., 60., 60])     #frequency (degrees)
x_cond = np.array([10., 0., -10.])    #x coordinate (feet)
y_cond = np.array([25., 25., 25.])    #y coordinate (feet)
subconds = np.array([1., 1., 1.])   #number of subconductors
d_cond = np.array([.5, .5, .5])   #diameter (inches)
d_bund = np.array([.5, .5, .5])
V_cond = np.array([335., 335., 335.])   #phase-phase voltage (kV)
I_cond = np.array([420., 420., 420.])   #phase current (amp)
p_cond = np.array([0., 120., 240.])    #phase angle (degrees)

E_x,E_y = E_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y)

E = np.sqrt(E_x**2 + E_y**2)

E_max = np.zeros((len(x),))
for i in range(len(x)):
    E_max[i] = max(E[:,i])

B_x,B_y = B_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y)

B = np.sqrt(B_x**2 + B_y**2)

B_max = np.zeros((len(x),))
for i in range(len(x)):
    B_max[i] = max(B[:,i])

with open('out.csv','w') as ofile:
    for z in zip(x,y,B_max,E_max):
        ofile.write('%s,%s,%s,%s\n' % tuple([str(i) for i in z]))

#plot the maxima at each point
plt.plot(x, E_max, 'bo')
plt.savefig('out_plot_E.png')
plt.close()

plt.plot(x, B_max, 'bo')
plt.savefig('out_plot_B.png')
plt.close()

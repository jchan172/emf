import numpy as np
import matplotlib.pyplot as plt

class FLDError(Exception):
    def __init__(self, message):
        self.message = message
    def __str__(self):
        return(self.message)

def forward_substitution(A,b):
    """forward substitution to solve a lower triangular matrix equation"""
    n = len(b)
    x = np.empty((n,))
    for i in range(n):
        x[i] = (b[i] - sum([A[i,j]*x[j] for j in range(i)]))/float(A[i,i])
    return(x)

def Crout_backward_substitution(A,b):
    """back substitution assuming all diagonal elements of A matrix equal 1"""
    n = len(b)
    x = np.empty((n,))
    for i in range(n-1,-1,-1):
        x[i] = b[i] - sum([A[i,j]*x[j] for j in range(i+1,n)])
    return(x)

def Crout_factorization(A):
    """Crout LU matrix decomposition, returning a single matrix storing
    L and U where the diagonal of U are omitted because they are all 1."""
    #copy input matrix and make declarations
    M = A[:,:]
    n = A.shape[0]
    LU = np.empty((n,n))
    #factorize
    for i in range(n):
        #fill in a column of L
        for j in range(i,n):
            LU[j,i] = M[j,i] - sum([LU[j,k]*LU[k,i] for k in range(j)])
        #fill in a row of U
        for j in range(i+1,n):
            LU[i,j] = (M[i,j] - sum([LU[i,k]*LU[k,j] for k in range(i)]))/LU[i,i]
    return(LU)

def E_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y):
    """Calculate the approximate electric field generated by a group of
    conductors. Each of the variables labeled '_cond' should be an numpy
    array of parameters, where each index in those arrays describes a
    unique conductor, i.e. the 0th value in each variable is attributed to
    one power line."""

    #convenient variables/constants
    epsilon = 8.854e-12
    C = 1./(2.*np.pi*epsilon)
    N = len(f_cond)     #number of conductors
    Z = len(x)          #number of sample points or x,y pairs

    #calculate the effective conductor diameters
    d_cond  = d_bund*((subconds*d_cond/d_bund)**(1./subconds))

    #conversions
    x_cond = x_cond*0.3048          #convert to meters
    y_cond = y_cond*0.3048          #convert to meters
    d_cond = d_cond*0.0254          #convert to meters
    V_cond = V_cond/np.sqrt(3)      #convert to ground reference from line-line
                                    #reference
                                    #leave in kV
    p_cond = p_cond*2*np.pi/360.    #convert to radians
    x      = x*0.3048               #convert to meters
    y      = y*0.3048               #convert to meters

    #compute the potential coefficient matrix
    P = np.empty((N,N))
    #diagonals
    for i in range(N):
        P[i,i] = C*np.log(4*y_cond[i]/d_cond[i])
    #other elements
    for i in range(N):
        for j in range(N):
            if(i != j):
                n = (x_cond[i] - x_cond[j])**2 + (y_cond[i] + y_cond[j])**2
                d = (x_cond[i] - x_cond[j])**2 + (y_cond[i] - y_cond[j])**2
                P[i,j] = C*np.log(np.sqrt(n/d))

    #Crout LU decomposition of the P matrix to avoid repeated inversion
    P_LU = Crout_factorization(P)

    #compute real and imaginary voltage phasors
    V_r = V_cond*np.cos(p_cond)
    V_i = V_cond*np.sin(p_cond)

    #compute real and imaginary charge phasors
    Q_r = Crout_backward_substitution(P_LU, forward_substitution(P_LU, V_r))
    Q_i = Crout_backward_substitution(P_LU, forward_substitution(P_LU, V_i))

    #compute components of the electric field phasors at each point, with each
    #column of E_x and E_y storing components due to each conductor, so that the
    #rows represent a spatial point across the ROW or an x,y pair
    Ex = np.empty((N,Z))
    Ey = np.empty((N,Z))
    #first compute the coefficients without the charges
    for i in range(Z):
        d1 = (x[i] - x_cond)**2 + (y[i] - y_cond)**2
        d2 = (x[i] - x_cond)**2 + (y[i] + y_cond)**2

        nx = C*(x[i] - x_cond)
        Ex[:,i] = nx/d1 - nx/d2

        ny1 = C*(y[i] - y_cond)
        ny2 = C*(y[i] + y_cond)
        Ey[:,i] = ny1/d1 - ny2/d2
    #now break up the coefficients into real and imaginary parts of E phasors
    Q_r = np.tile(np.reshape(Q_r, (N, 1)), (1,Z))
    Q_i = np.tile(np.reshape(Q_i, (N, 1)), (1,Z))
    Ex_r = Ex*Q_r
    Ex_i = Ex*Q_i
    Ey_r = Ey*Q_r
    Ey_i = Ey*Q_i

    #sum the real parts and imaginary parts of each phasor for each x,y
    Ex_r = np.sum(Ex_r, axis = 0)
    Ex_i = np.sum(Ex_i, axis = 0)
    Ey_r = np.sum(Ey_r, axis = 0)
    Ey_i = np.sum(Ey_i, axis = 0)

    #find the magnitude of each phasor
    Ex_max = np.sqrt(Ex_r**2 + Ex_i**2)
    Ey_max = np.sqrt(Ey_r**2 + Ey_i**2)

    return(Ex_max, Ey_max)


def B_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y):
    """Calculate the approximate magnetic field generated by a group of
    conductors. Each of the variables labeled '_cond' should be an numpy
    array of parameters, where each index in those arrays describes a
    unique conductor, i.e. the 0th value in each variable is attributed to
    one power line."""

    #Define a time interval with the maximum amount of time required to
    #complete one cycle (the period).
    if(any(np.diff(f_cond))):
        raise(FLDError('At least one input frequency is different than the others. Calculations assume they are uniform.'))
    T = 1./f_cond[0]
    t = np.linspace(0, T, 1001)

    #convenient variables/constants
    mu = 4*np.pi*1e-7
    C = 1./(2*np.pi)
    L = len(t)          #number of time steps
    N = len(f_cond)     #number of conductors
    Z = len(x)          #number of sample points or x,y pairs

    #conversions
    w_cond = 2*np.pi*f_cond         #convert to radians
    x_cond = x_cond*0.3048          #convert to meters
    y_cond = y_cond*0.3048          #convert to meters
    p_cond = p_cond*2*np.pi/360.    #convert to radians
    x      = x*0.3048               #convert to meters
    y      = y*0.3048               #convert to meters

    #generate time varying current signals for each conductor, with each
    #conductor in a column and each row representative of a time step
    I = np.empty((L,N))
    for i in range(N):
        I[:,i] = I_cond[i]*np.cos(w_cond[i]*t + p_cond[i])

    #Compute x and y components of the B field at each point. The columns
    #of B_x and B_y represent x,y pairs and the rows represent time steps
    #or current snapshots
    B_x = np.zeros((L,Z))
    B_y = np.zeros((L,Z))
    for i in range(Z): #x,y pairs
        for j in range(L): #time steps
            for k in range(N): #conductors
                dx = x[i] - x_cond[k]
                dy = y[i] - y_cond[k]
                d = np.sqrt(dx**2 + dy**2)
                B = C*I[j,k]/d
                theta = np.arctan(np.abs(dy/dx))
                B_x[j,i] += -np.sign(dy)*np.cos(theta)*B
                B_y[j,i] += np.sign(dx)*np.sin(theta)*B

    #compute resultant field magnitude
    #B = np.sqrt(B_x**2 + B_y**2)
    return(B_x, B_y)

#sample locations
x = np.arange(-25, 26)
y = 3*np.ones((len(x),))

#conductor properties
f_cond = np.array([60., 60., 60.])     #frequency (degrees)
x_cond = np.array([-5., 0., 5.])    #x coordinate (feet)
y_cond = np.array([15., 20., 15])    #y coordinate (feet)
subconds = np.array([1., 1., 1.])   #number of subconductors
d_cond = np.array([1., 1., 1.])   #diameter (inches)
d_bund = np.array([1., 1., 1.])
V_cond = np.array([500., 500., 500.])   #phase-phase voltage (kV)
I_cond = np.array([500., 500., 500.])   #phase current (amp)
p_cond = np.array([0., 120., 240.])    #phase angle (degrees)

E_x,E_y = E_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y)

E_max = np.sqrt(E_x**2 + E_y**2)


B_x,B_y = B_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y)

B = np.sqrt(B_x**2 + B_y**2)

B_max = np.zeros((len(x),))
for i in range(len(x)):
    B_max[i] = max(B[:,i])

with open('new_model_out.csv','w') as ofile:
    ofile.write('%s,%s,%s\n' % ('x','B_max','E_max'))
    for z in zip(x,B_max,E_max):
        ofile.write('%s,%s,%s\n' % tuple([str(i) for i in z]))

#plot the maxima at each point
plt.plot(x, E_max, 'bo')
plt.savefig('new_model_plot_E.png')
plt.close()

plt.plot(x, B_max, 'bo')
plt.savefig('new_model_plot_B.png')
plt.close()

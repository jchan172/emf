import numpy as np
import pandas as pd

class FLDError(Exception):
    def __init__(self, message):
        self.message = message
    def __str__(self):
        return(self.message)

def E_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y):
    """Calculate the approximate electric field generated by a group of
    conductors. Each of the variables labeled '_cond' should be an numpy
    array of parameters, where each index in those arrays describes a
    unique conductor, i.e. the 0th value in each variable is attributed to
    one power line."""

    #convenient variables/constants
    epsilon = 8.854e-12
    C = 1./(2.*np.pi*epsilon)
    N = len(f_cond)     #number of conductors
    Z = len(x)          #number of sample points or x,y pairs

    #calculate the effective conductor diameters
    d_cond  = d_bund*((subconds*d_cond/d_bund)**(1./subconds))

    #conversions
    x_cond = x_cond*0.3048          #convert to meters
    y_cond = y_cond*0.3048          #convert to meters
    d_cond = d_cond*0.0254          #convert to meters
    V_cond = V_cond/np.sqrt(3)      #convert to ground reference from line-line
                                    #reference
                                    #leave in kV
    p_cond = p_cond*2*np.pi/360.    #convert to radians
    x      = x*0.3048               #convert to meters
    y      = y*0.3048               #convert to meters

    #compute the potential coefficient matrix
    P = np.empty((N,N))
    #diagonals
    for i in range(N):
        P[i,i] = C*np.log(4*y_cond[i]/d_cond[i])
    #other elements
    for a in range(N):
        for b in range(N):
            if(a != b):
                n = (x_cond[a] - x_cond[b])**2 + (y_cond[a] + y_cond[b])**2
                d = (x_cond[a] - x_cond[b])**2 + (y_cond[a] - y_cond[b])**2
                P[a,b] = C*np.log(np.sqrt(n/d))

    #initialize complex voltage phasors
    V = V_cond*(np.cos(p_cond) + complex(1j)*np.sin(p_cond))

    #compute real and imaginary charge phasors
    Q = np.linalg.solve(P, V)

    #compute components of the electric field phasors at each point, with each
    #column of E_x and E_y storing components due to each conductor, so that the
    #rows represent a spatial point across the ROW or an x,y pair
    Ex = np.empty((N,Z))
    Ey = np.empty((N,Z))
    #first compute the coefficients without the charges
    for a in range(Z):
        #denominators, squared distance between the point and the conductors
        d1 = (x[a] - x_cond)**2 + (y[a] - y_cond)**2
        d2 = (x[a] - x_cond)**2 + (y[a] + y_cond)**2
        #x component numerator, the same for the conductor and its image
        nx = C*(x[a] - x_cond)
        #y component numerators, different for the conductor and its image
        ny1 = C*(y[a] - y_cond)
        ny2 = C*(y[a] + y_cond)
        #evaluate
        Ex[:,a] = nx/d1 - nx/d2
        Ey[:,a] = ny1/d1 - ny2/d2

    #multiply the charges by the field coefficients calculated above
    Q = np.tile(np.reshape(Q, (N, 1)), (1,Z))
    Ex = Ex*Q
    Ey = Ey*Q

    #sum the real parts and imaginary parts of each phasor for each sample
    #point, yielding the sum of phasors for each conductor, the final phasor
    #for each point
    Ex = np.sum(Ex, axis = 0)
    Ey = np.sum(Ey, axis = 0)

    return(Ex, Ey)


def B_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y):
    """Calculate the approximate magnetic field generated by a group of
    conductors. Each of the variables labeled '_cond' should be an numpy
    array of parameters, where each index in those arrays describes a
    unique conductor, i.e. the 0th value in each variable is attributed to
    one power line."""

    #convenient variables/constants
    mu = 4*np.pi*1e-7
    C = mu/(2*np.pi)
    N = len(f_cond)     #number of conductors
    Z = len(x)          #number of sample points or x,y pairs

    #conversions
    w_cond = 2*np.pi*f_cond         #convert to radians
    x_cond = x_cond*0.3048          #convert to meters
    y_cond = y_cond*0.3048          #convert to meters
    p_cond = p_cond*2*np.pi/360.    #convert to radians
    x      = x*0.3048               #convert to meters
    y      = y*0.3048               #convert to meters

    #initialize complex current phasors
    I = I_cond*(np.cos(p_cond) + complex(1j)*np.sin(p_cond))

    #compute magnetic field component phasors for each x,y point
    Bx = np.zeros((Z,), dtype = complex)
    By = np.zeros((Z,), dtype = complex)
    for a in range(Z): #x,y pairs
        for b in range(N): #conductors
            dx = x[a] - x_cond[b]
            dy = y[a] - y_cond[b]
            #magnitude phasor
            B = C*I[b]/np.sqrt(dx**2 + dy**2)
            #break it up into components
            theta = np.arctan(abs(dy/dx))
            print theta,B
            """
            if(dx == 0.):
                Bx[a] -= np.sign(dy)*B
            elif(dy == 0.):
                By[a] += np.sign(dx)*B
            else:
                Bx[a] -= np.sign(dy)*np.cos(theta)*B
                By[a] += np.sign(dx)*np.sin(theta)*B"""
            Bx[a] -= np.sign(dy)*np.sin(theta)*B
            By[a] += np.sign(dx)*np.cos(theta)*B

    #convert from units of tesla to milligauss
    Bx *= 1e7
    By *= 1e7

    return(Bx, By)

def real_output(Ph_x, Ph_y):
    """Convert vectors of complex x and y phasors into real quantities"""
    #amplitude along each component
    mag_x = np.sqrt(np.real(Ph_x)**2 + np.imag(Ph_x)**2)
    mag_y = np.sqrt(np.real(Ph_y)**2 + np.imag(Ph_y)**2)
    #"product"
    prod = np.sqrt(mag_x**2 + mag_y**2)
    #"max"
    t = np.linspace(0,2*np.pi,1001)
    maxi = np.zeros((len(Ph_x),))
    for i in range(len(maxi)):
        Rx = mag_x[i]*np.cos(t + np.arctan(np.imag(Ph_x[i])/np.real(Ph_x[i])))
        Ry = mag_y[i]*np.cos(t + np.arctan(np.imag(Ph_y[i])/np.real(Ph_y[i])))
        maxi[i] = max(np.sqrt(Rx**2 + Ry**2))

    #R = np.sqrt((np.real(Ph_x) + np.real(Ph_y))**2 + (np.imag(Ph_x) + np.imag(Ph_y))**2)
    #maxi = np.abs(R)
    #print maxi

    return(mag_x, mag_y, prod, maxi)

#sample locations
x = np.arange(-25, 26)
y = 3*np.ones((len(x),))

#conductor properties
f_cond = np.array([60., 60.])     #frequency (degrees)
x_cond = np.array([-10., 10])    #x coordinate (feet)
y_cond = np.array([25., 25.])    #y coordinate (feet)
subconds = np.array([1., 1.])   #number of subconductors
d_cond = np.array([1., 1.])   #diameter (inches)
d_bund = np.array([1., 1.])
V_cond = np.array([250., 250.])   #phase-phase voltage (kV)
I_cond = np.array([250., 250.])   #phase current (amp)
p_cond = np.array([0., 180.])    #phase angle (degrees)

Ex, Ey = E_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y)

E_x,E_y,E_prod,E_max = real_output(Ex,Ey)

df = pd.read_table('TEST.DAT', skiprows = [0,1,2,3,5,6], delim_whitespace = True)

Experc = 100*(E_x - df['E_Horz'])/abs(df['E_Horz'])
Eyperc = 100*(E_y - df['E_Vert'])/abs(df['E_Vert'])
Eprodperc = 100*(E_prod - df['E_PROD'])/abs(df['E_PROD'])
Emaxperc = 100*(E_max  - df['E_MAX'])/abs(df['E_MAX'])

with open('new_model_out_E.txt','w') as ofile:
    ofile.write('%3s\t%10s\t%10s\t%10s\t%10s\t%10s\t%10s\t%10s\t%10s\n' % ('x','Ex','Experc','Ey','Eyperc','Eprod','Eprodp','Emax','Emaxp'))
    for z in zip(x,E_x,Experc,E_y,Eyperc,E_prod,Eprodperc,E_max,Emaxperc):
        ofile.write('%3d\t%10.4f\t%10.4f\t%10.4f\t%10.4f\t%10.4f\t%10.4f\t%10.4f\t%10.4f\n' % z)


Bx, By = B_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y)

B_x,B_y,B_prod,B_max = real_output(Bx,By)


Bxperc = 100*(B_x - df['B_Horz'])/abs(df['B_Horz'])
Byperc = 100*(B_y - df['B_Vert'])/abs(df['B_Vert'])
Bprodperc = 100*(B_prod - df['B_PROD'])/abs(df['B_PROD'])
Bmaxperc = 100*(B_max  - df['B_MAX'])/abs(df['B_MAX'])

with open('new_model_out_B.txt','w') as ofile:
    ofile.write('%3s\t%10s\t%10s\t%10s\t%10s\t%10s\t%10s\t%10s\t%10s\n' % ('x','Bx','Bxperc','By','Byperc','Bprod','Bprodp','Bmax','Bmaxp'))
    for z in zip(x,B_x,Bxperc,B_y,Byperc,B_prod,Bprodperc,B_max,Bmaxperc):
        ofile.write('%3d\t%10.4f\t%10.4f\t%10.4f\t%10.4f\t%10.4f\t%10.4f\t%10.4f\t%10.4f\n' % z)

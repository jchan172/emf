import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

class FLDError(Exception):
    def __init__(self, message):
        self.message = message
    def __str__(self):
        return(self.message)

def forward_substitution(A,b):
    """forward substitution to solve a lower triangular matrix equation"""
    n = len(b)
    x = np.empty((n,))
    for i in range(n):
        x[i] = (b[i] - sum([A[i,j]*x[j] for j in range(i)]))/float(A[i,i])
    return(x)

def Crout_backward_substitution(A,b):
    """back substitution assuming all diagonal elements of A matrix equal 1"""
    n = len(b)
    x = np.empty((n,))
    for i in range(n-1,-1,-1):
        x[i] = b[i] - sum([A[i,j]*x[j] for j in range(i+1,n)])
    return(x)

def Crout_factorization(A):
    """Crout LU matrix decomposition, returning a single matrix storing
    L and U where the diagonal of U are omitted because they are all 1."""
    #copy input matrix and make declarations
    M = A[:,:]
    n = A.shape[0]
    LU = np.empty((n,n))
    #factorize
    for i in range(n):
        #fill in a column of L
        for j in range(i,n):
            LU[j,i] = M[j,i] - sum([LU[j,k]*LU[k,i] for k in range(j)])
        #fill in a row of U
        for j in range(i+1,n):
            LU[i,j] = (M[i,j] - sum([LU[i,k]*LU[k,j] for k in range(i)]))/LU[i,i]
    return(LU)

def E_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y):
    """Calculate the approximate electric field generated by a group of
    conductors. Each of the variables labeled '_cond' should be an numpy
    array of parameters, where each index in those arrays describes a
    unique conductor, i.e. the 0th value in each variable is attributed to
    one power line."""

    #convenient variables/constants
    epsilon = 8.854e-12
    C = 1./(2.*np.pi*epsilon)
    N = len(f_cond)     #number of conductors
    Z = len(x)          #number of sample points or x,y pairs

    #calculate the effective conductor diameters
    d_cond  = d_bund*((subconds*d_cond/d_bund)**(1./subconds))

    #conversions
    x_cond = x_cond*0.3048          #convert to meters
    y_cond = y_cond*0.3048          #convert to meters
    d_cond = d_cond*0.0254          #convert to meters
    V_cond = V_cond/np.sqrt(3)      #convert to ground reference from line-line
                                    #reference
                                    #leave in kV
    p_cond = p_cond*2*np.pi/360.    #convert to radians
    x      = x*0.3048               #convert to meters
    y      = y*0.3048               #convert to meters

    #compute the potential coefficient matrix
    P = np.empty((N,N))
    #diagonals
    for i in range(N):
        P[i,i] = C*np.log(4*y_cond[i]/d_cond[i])
    #other elements
    for i in range(N):
        for j in range(N):
            if(i != j):
                n = (x_cond[i] - x_cond[j])**2 + (y_cond[i] + y_cond[j])**2
                d = (x_cond[i] - x_cond[j])**2 + (y_cond[i] - y_cond[j])**2
                P[i,j] = C*np.log(np.sqrt(n/d))

    #Crout LU decomposition of the P matrix to avoid repeated inversion
    P_LU = Crout_factorization(P)

    #compute real and imaginary voltage phasors
    V_r = V_cond*np.cos(p_cond)
    V_i = V_cond*np.sin(p_cond)

    #compute real and imaginary charge phasors
    Q_r = Crout_backward_substitution(P_LU, forward_substitution(P_LU, V_r))
    Q_i = Crout_backward_substitution(P_LU, forward_substitution(P_LU, V_i))

    #compute components of the electric field phasors at each point, with each
    #column of E_x and E_y storing components due to each conductor, so that the
    #rows represent a spatial point across the ROW or an x,y pair
    Ex = np.empty((N,Z))
    Ey = np.empty((N,Z))
    #first compute the coefficients without the charges
    for i in range(Z):
        d1 = (x[i] - x_cond)**2 + (y[i] - y_cond)**2
        d2 = (x[i] - x_cond)**2 + (y[i] + y_cond)**2

        nx = C*(x[i] - x_cond)
        Ex[:,i] = nx/d1 - nx/d2

        ny1 = C*(y[i] - y_cond)
        ny2 = C*(y[i] + y_cond)
        Ey[:,i] = ny1/d1 - ny2/d2
    #now break up the coefficients into real and imaginary parts of E phasors
    Q_r = np.tile(np.reshape(Q_r, (N, 1)), (1,Z))
    Q_i = np.tile(np.reshape(Q_i, (N, 1)), (1,Z))
    Ex_r = Ex*Q_r
    Ex_i = Ex*Q_i
    Ey_r = Ey*Q_r
    Ey_i = Ey*Q_i

    #sum the real parts and imaginary parts of each phasor for each sample
    #point, yielding the sum of phasors for each conductor
    Ex_r = np.sum(Ex_r, axis = 0)
    Ex_i = np.sum(Ex_i, axis = 0)
    Ey_r = np.sum(Ey_r, axis = 0)
    Ey_i = np.sum(Ey_i, axis = 0)

    #find the magnitude and phase of the phasors at each point
    Ex_mag = np.sqrt(Ex_r**2 + Ex_i**2)
    Ex_phase = np.arctan(Ex_i/Ex_r)
    Ey_mag = np.sqrt(Ey_r**2 + Ey_i**2)
    Ey_phase = np.arctan(Ey_i/Ey_r)

    return(Ex_mag, Ex_phase, Ey_mag, Ey_phase)


def B_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y):
    """Calculate the approximate magnetic field generated by a group of
    conductors. Each of the variables labeled '_cond' should be an numpy
    array of parameters, where each index in those arrays describes a
    unique conductor, i.e. the 0th value in each variable is attributed to
    one power line."""

    #convenient variables/constants
    mu = 4*np.pi*1e-7
    C = 1./(2*np.pi)
    N = len(f_cond)     #number of conductors
    Z = len(x)          #number of sample points or x,y pairs

    #conversions
    w_cond = 2*np.pi*f_cond         #convert to radians
    x_cond = x_cond*0.3048          #convert to meters
    y_cond = y_cond*0.3048          #convert to meters
    p_cond = p_cond*2*np.pi/360.    #convert to radians
    x      = x*0.3048               #convert to meters
    y      = y*0.3048               #convert to meters

    #generate time varying current signals for each conductor, with each
    #conductor in a column and each row representative of a time step
    I = np.empty((L,N))
    for i in range(N):
        I[:,i] = I_cond[i]*np.cos(w_cond[i]*t + p_cond[i])

    #Compute x and y components of the B field at each point. The columns
    #of B_x and B_y represent x,y pairs and the rows represent time steps
    #or current snapshots
    B_x = np.zeros((L,Z))
    B_y = np.zeros((L,Z))
    for i in range(Z): #x,y pairs
        for j in range(L): #time steps
            for k in range(N): #conductors
                dx = x[i] - x_cond[k]
                dy = y[i] - y_cond[k]
                d = np.sqrt(dx**2 + dy**2)
                B = C*I[j,k]/d
                theta = np.arctan(np.abs(dy/dx))
                B_x[j,i] += -np.sign(dy)*np.cos(theta)*B
                B_y[j,i] += np.sign(dx)*np.sin(theta)*B

    #compute resultant field magnitude
    #B = np.sqrt(B_x**2 + B_y**2)
    return(B_x, B_y)

#sample locations
x = np.arange(-25, 26)
y = 3*np.ones((len(x),))

#conductor properties
f_cond = np.array([60., 60., 60.])     #frequency (degrees)
x_cond = np.array([-5., 0., 5.])    #x coordinate (feet)
y_cond = np.array([15., 20., 15])    #y coordinate (feet)
subconds = np.array([1., 1., 1.])   #number of subconductors
d_cond = np.array([1., 1., 1.])   #diameter (inches)
d_bund = np.array([1., 1., 1.])
V_cond = np.array([500., 500., 500.])   #phase-phase voltage (kV)
I_cond = np.array([500., 500., 500.])   #phase current (amp)
p_cond = np.array([0., 120., 240.])    #phase angle (degrees)

E_x,E_x_ph,E_y,E_y_ph = E_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y)

E_prod = np.sqrt(E_x**2 + E_y**2)

M = np.empty((len(E_x), 2))
M[:,0] = (E_x)
M[:,1] = (E_y)
E_max = np.amax(M, axis = 1)

R = (E_x**2)*np.cos(2*E_x_ph) + (E_y**2)*np.cos(2*E_y_ph)
I = (E_x**2)*np.sin(2*E_x_ph) + (E_y**2)*np.cos(2*E_y_ph)

t = np.linspace(0,2*np.pi,1000)
for i in range(len(E_max)):
    mag = np.sqrt((E_x[i]*np.cos(t+E_x_ph[i]))**2 + (E_y[i]*np.cos(t+E_y_ph[i]))**2)
    E_max[i] = max(abs(mag))

print(np.sqrt((E_x*np.cos(E_x_ph))**2 + (E_y*np.sin(E_y_ph))**2))

#B_x,B_y = B_field(f_cond, x_cond, y_cond, subconds, d_cond, d_bund, V_cond, I_cond, p_cond, x, y)

#B = np.sqrt(B_x**2 + B_y**2)

#B_max = np.zeros((len(x),))
#for i in range(len(x)):
#    B_max[i] = max(B[:,i])

df = pd.read_table('TEST.DAT', skiprows = [0,1,2,3,5,6], delim_whitespace = True)

Experc = (E_x - df['E_Horz'])/abs(df['E_Horz'])
Eyperc = (E_y - df['E_Vert'])/abs(df['E_Vert'])
Eprodperc = (E_prod - df['E_PROD'])/abs(df['E_PROD'])
Emaxperc = (E_max  - df['E_MAX'])/abs(df['E_MAX'])

with open('new_model_out.txt','w') as ofile:
    ofile.write('%3s\t%7s\t%7s\t%7s\t%7s\t%7s\t%7s\t%7s\t%7s\n' % ('x','Ex','Experc','Ey','Eyperc','Eprod','Eprodp','Emax','Emaxp'))
    for z in zip(x,E_x,Experc,E_y,Eyperc,E_prod,Eprodperc,E_max,Emaxperc):
        ofile.write('%3d\t%7.4f\t%7.4f\t%7.4f\t%7.4f\t%7.4f\t%7.4f\t%7.4f\t%7.4f\n' % z)

#plot the maxima at each point
plt.plot(x, E_max, 'bo')
plt.savefig('new_model_plot_E.png')
plt.close()

#plt.plot(x, B_max, 'bo')
#plt.savefig('new_model_plot_B.png')
#plt.close()
